/*
 * FlintMC
 * Copyright (C) 2020-2021 LabyMedia GmbH and contributors
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package net.flintmc.gradle.patch;

import com.cloudbees.diff.Hunk;
import com.cloudbees.diff.PatchException;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.flintmc.gradle.patch.context.LocalPatchContextProvider;
import net.flintmc.gradle.patch.context.PatchContextProvider;
import net.flintmc.gradle.patch.report.HunkReport;
import net.flintmc.gradle.patch.report.PatchReport;
import net.flintmc.gradle.patch.state.PatchMode;
import net.flintmc.gradle.patch.state.PatchStatus;

/** Applies contextual patches to files. The patch file can contain patches for multiple files. */
public final class PatchContextual {

  public static final String MAGIC = "# This patch file was generated by NetBeans IDE";

  private static final Pattern unifiedRangePattern =
      Pattern.compile("@@ -(\\d+)(,\\d+)? \\+(\\d+)(,\\d+)? @@(\\s.*)?");
  private static final Pattern baseRangePattern =
      Pattern.compile("\\*\\*\\* (\\d+)(,\\d+)? \\*\\*\\*\\*");
  private static final Pattern modifiedRangePattern = Pattern.compile("--- (\\d+)(,\\d+)? ----");
  private static final Pattern normalChangeRangePattern =
      Pattern.compile("(\\d+),(\\d+)c(\\d+),(\\d+)");
  private static final Pattern normalAddRangePattern = Pattern.compile("(\\d+)a(\\d+),(\\d+)");
  private static final Pattern normalDeleteRangePattern = Pattern.compile("(\\d+),(\\d+)d(\\d+)");
  private static final Pattern binaryHeaderPattern =
      Pattern.compile("MIME: (.*?); encoding: (.*?); length: (-?\\d+?)");

  private final PatchContextProvider contextProvider;
  private final String originalPrefix;
  private final String modifiedPrefix;
  private final PatchFile patchFile;
  private final File suggestedContext;
  private boolean c14nAccess = false;
  private boolean c14nWhitespace = false;
  private int maximalAttempt = 0;
  private File context;
  private BufferedReader patchReader;
  private String patchLine;
  private boolean patchLineRead;
  private int lastPatchedLine;

  /**
   * Constructs a new {@link PatchContextual} with the given parameters.
   *
   * @param patchFile The patch file.
   * @param context The context provider for the patch file.
   * @param originalPrefix The original prefix.
   * @param modifiedPrefix The modified prefix.
   */
  private PatchContextual(
      PatchFile patchFile,
      PatchContextProvider context,
      String originalPrefix,
      String modifiedPrefix) {
    this.patchFile = patchFile;
    this.suggestedContext = null;
    this.contextProvider = context != null ? context : new LocalPatchContextProvider(this);
    this.originalPrefix = originalPrefix;
    this.modifiedPrefix = modifiedPrefix;
  }

  /**
   * Creates a new {@link PatchContextual} with the given parameters.
   *
   * @param patchFile The patch file.
   * @param context The context provider for the patch file.
   * @return A created patch contextual.
   */
  public static PatchContextual create(PatchFile patchFile, PatchContextProvider context) {
    return create(patchFile, context, null, null);
  }

  /**
   * Creates a new {@link PatchContextual} with the given parameters.
   *
   * @param patchFile The patch file.
   * @param context The context provider for the patch file.
   * @param originalPrefix The original prefix.
   * @param modifiedPrefix The modified prefix.
   * @return A created patch contextual.
   */
  public static PatchContextual create(
      PatchFile patchFile,
      PatchContextProvider context,
      String originalPrefix,
      String modifiedPrefix) {
    return new PatchContextual(patchFile, context, originalPrefix, modifiedPrefix);
  }

  public void setCanonicalization(boolean access, boolean whitespace) {
    this.c14nAccess = access;
    this.c14nWhitespace = whitespace;
  }

  /**
   * Changes the maximal attempts.
   *
   * @param maximalAttempt The new maximal attempts.
   */
  public void setMaximalAttempt(int maximalAttempt) {
    this.maximalAttempt = maximalAttempt;
  }

  /**
   * @param dryRun true if the method should not make any modifications to files, false otherwise
   * @return
   * @throws PatchException
   * @throws IOException
   */
  public List<PatchReport> patch(boolean dryRun) throws PatchException, IOException {
    List<PatchReport> report = new ArrayList<>();
    initialize();
    try {
      this.patchLine = this.patchReader.readLine();
      List<PatchSingle> patches = new ArrayList<>();
      while (true) {
        PatchSingle patch = getNextPatch();
        if (patch == null) {
          break;
        }
        patches.add(patch);
      }
      computeContext(patches);
      for (PatchSingle patch : patches) {
        try {
          report.add(applyPatch(patch, dryRun));
        } catch (Exception exception) {
          report.add(
              PatchReport.create(
                  patch.getTargetPath(),
                  patch.isBinary(),
                  PatchStatus.FAILURE,
                  exception,
                  new ArrayList<>()));
        }
      }
      return report;
    } finally {
      if (this.patchReader != null)
        try {
          this.patchReader.close();
        } catch (IOException ignored) {
        }
    }
  }

  /**
   * Initlaizes the patch contextual.
   *
   * @throws IOException If an I/O error has occurred.
   */
  private void initialize() throws IOException {
    this.patchReader = new BufferedReader(new InputStreamReader(this.patchFile.openStream()));
    if (!this.patchFile.requiresFurtherProcessing()) {
      return;
    }

    Charset encoding = StandardCharsets.ISO_8859_1;
    String line = patchReader.readLine();
    if (MAGIC.equals(line)) {
      encoding = StandardCharsets.UTF_8; // NOI18N
      line = patchReader.readLine();
    }
    this.patchReader.close();

    byte[] buffer = new byte[MAGIC.length()];
    int read;
    try (InputStream inputStream = this.patchFile.openStream()) {
      read = inputStream.read(buffer);
    }
    if (read != -1 && MAGIC.equals(new String(buffer, StandardCharsets.UTF_8))) { // NOI18N
      encoding = StandardCharsets.UTF_8;
    }
    this.patchReader = new BufferedReader(new InputStreamReader(patchFile.openStream(), encoding));
  }

  /**
   * Applied the patch.
   *
   * @param patch The patch to be applied.
   * @param dryRun {@code true} if the run is to be repeated, otherwise {@code false}.
   * @return The applied patch.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private PatchReport applyPatch(PatchSingle patch, boolean dryRun)
      throws IOException, PatchException {
    this.lastPatchedLine = 1;
    List<String> target = this.contextProvider.getData(patch);
    List<HunkReport> hunkReports = new ArrayList<>();
    if (target != null && !patch.isBinary()) {
      if (this.patchCreatesNewFileThatAlreadyExists(patch, target)) {
        for (int x = 0; x < patch.getHunks().length; x++) {
          hunkReports.add(HunkReport.create(PatchStatus.SKIPPED, null, 0, 0, x));
        }
        return PatchReport.create(
            patch.getTargetIndex(), patch.isBinary(), PatchStatus.SKIPPED, null, hunkReports);
      }
    } else {
      target = new ArrayList<>();
    }
    if (patch.getPatchMode() == PatchMode.DELETE) {
      target = new ArrayList<>();
    } else {
      if (!patch.isBinary()) {
        int x = 0;
        for (Hunk hunk : patch.getHunks()) {
          x++;
          try {
            hunkReports.add(applyHunk(target, hunk, x));
          } catch (Exception exception) {
            hunkReports.add(HunkReport.create(PatchStatus.FAILURE, exception, 0, 0, x, hunk));
          }
        }
      }
    }
    if (!dryRun) {
      contextProvider.setData(patch, target);
    }
    for (HunkReport hunk : hunkReports) {
      if (hunk.getPatchStatus() == PatchStatus.FAILURE) {
        if (!dryRun) {
          this.contextProvider.setFailed(patch, makeReject(hunkReports));
        }
        return PatchReport.create(
            patch.getTargetPath(),
            patch.isBinary(),
            PatchStatus.FAILURE,
            hunk.getFailure(),
            hunkReports);
      }
    }
    return PatchReport.create(
        patch.getTargetPath(), patch.isBinary(), PatchStatus.PATCHED, null, hunkReports);
  }

  private boolean patchCreatesNewFileThatAlreadyExists(PatchSingle patch, List<String> originalFile)
      throws PatchException {
    if (patch.getHunks().length != 1) {
      return false;
    }

    Hunk hunk = patch.getHunks()[0];
    if (hunk.baseStart != 0
        || hunk.baseCount != 0
        || hunk.modifiedStart != 1
        || hunk.modifiedCount != originalFile.size()) {
      return false;
    }

    List<String> target = new ArrayList<>(hunk.modifiedCount);
    this.applyHunk(target, hunk, 0);
    return target.equals(originalFile);
  }

  private List<String> makeReject(List<HunkReport> hunkReports) {
    List<String> lines = new ArrayList<>();
    for (HunkReport report : hunkReports) {
      if (report.hasFailed()) {
        lines.add("++++ REJECTED HUNK: " + report.getIndex());
        lines.addAll(report.getHunk().lines);
        lines.add("++++ END HUNK");
      }
    }
    return lines;
  }

  /**
   * Applied the hunk.
   *
   * @param target The target to which the patch should be applied.
   * @param hunk The hunk to applied.
   * @param hunkIdentifier The identifier of the hunk.
   * @return The applied hunk.
   * @throws PatchException If the patch is invalid.
   */
  private HunkReport applyHunk(List<String> target, Hunk hunk, int hunkIdentifier)
      throws PatchException {
    int index = -1;
    int attempt = 0;
    while (index == -1 && attempt <= this.maximalAttempt) {
      index = findHunkIndex(target, hunk, attempt, hunkIdentifier);
      if (index != -1) {
        break;
      }
      attempt++;
    }

    if (index == -1) {
      throw new PatchException("Cannot find hunk target");
    }

    return applyHunk(target, hunk, index, false, attempt, hunkIdentifier);
  }

  /**
   * Finds a hunk index.
   *
   * @param target The target to which the patch should be applied.
   * @param hunk The hunk to applied.
   * @param attempt The attempts to find the hunk index.
   * @param hunkIdentifier The identifier of the hunk.
   * @return The hunk index.
   * @throws PatchException If the patch is invalid.
   */
  private int findHunkIndex(List<String> target, Hunk hunk, int attempt, int hunkIdentifier)
      throws PatchException {
    int modifiedStartIndex = hunk.modifiedStart; // first guess from the hunk range specification
    if (modifiedStartIndex >= this.lastPatchedLine
        && applyHunk(target, hunk, modifiedStartIndex, true, attempt, hunkIdentifier)
            .getPatchStatus()
            .isSuccess()) {
      return modifiedStartIndex;
    } else {
      // try to search for the context
      for (int index = modifiedStartIndex - 1; index >= this.lastPatchedLine; index--) {
        if (applyHunk(target, hunk, index, true, attempt, hunkIdentifier)
            .getPatchStatus()
            .isSuccess()) {
          return index;
        }
      }
      for (int index = modifiedStartIndex + 1; index < target.size(); index++) {
        if (applyHunk(target, hunk, index, true, attempt, hunkIdentifier)
            .getPatchStatus()
            .isSuccess()) {
          return index;
        }
      }
    }
    return -1;
  }

  /**
   * Applied the hunk.
   *
   * @param target The target to which the patch should be applied.
   * @param hunk The hunk to applied.
   * @param index The hunk index.
   * @param dryRun {@code true} if the run is to be repeated, otherwise {@code false}.
   * @param attempt The attempts of the try.
   * @param hunkIdentifier The identifier of the hunk.
   * @return The applied hunk report.
   * @throws PatchException If the patch is invalid.
   */
  private HunkReport applyHunk(
      List<String> target, Hunk hunk, int index, boolean dryRun, int attempt, int hunkIdentifier)
      throws PatchException {
    int startIndex = index;
    index--;
    int hunkIndex = -1;
    for (String hunkLine : hunk.lines) {
      hunkIndex++;
      boolean isAddition = hunkLine.charAt(0) == '+';
      if (!isAddition) {
        if (index >= target.size()) {
          if (dryRun) {
            return HunkReport.create(PatchStatus.FAILURE, null, index, attempt, hunkIdentifier);
          } else {
            throw new PatchException("Unapplicable hunk #" + hunkIdentifier + " @@ " + startIndex);
          }
        }
        boolean match = PatchHelper.similar(this, target.get(index), hunkLine.substring(1));
        if (!match && attempt != 0 && !isRemovalLine(hunkLine)) {
          match = hunkIndex < attempt || hunkIndex >= hunk.lines.size() - attempt;
        }
        if (!match) {
          if (dryRun) {
            return HunkReport.create(PatchStatus.FAILURE, null, index, attempt, hunkIdentifier);
          } else {
            throw new PatchException("Unapplicable hunk #" + hunkIdentifier + " @@ " + startIndex);
          }
        }
      }
      if (dryRun) {
        if (isAddition) {
          index--;
        }
      } else {
        if (isAddition) {
          target.add(index, hunkLine.substring(1));
        } else if (isRemovalLine(hunkLine)) {
          target.remove(index);
          index--;
        }
      }
      index++;
    }
    index++;
    this.lastPatchedLine = index;
    return HunkReport.create(
        attempt != 0 ? PatchStatus.TRIED : PatchStatus.PATCHED,
        null,
        startIndex,
        attempt,
        hunkIdentifier);
  }

  private boolean isRemovalLine(String hunkLine) {
    return hunkLine.charAt(0) == '-';
  }

  /**
   * Retrieves the next patch file.
   *
   * @return The next patch file.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private PatchSingle getNextPatch() throws IOException, PatchException {
    PatchSingle patch = new PatchSingle();
    while (true) {
      String line = this.readPatchLine();
      if (line == null) {
        return null;
      }

      if (line.startsWith("Index:")) {
        patch.setTargetPath(line.substring(6).trim());
      } else if (line.startsWith("MIME: application/octet-stream;")) {
        this.unreadPatchLine();
        this.readBinaryPatchContent(patch);
        break;
      } else if (line.startsWith("--- ")) {
        this.unreadPatchLine();
        this.readPatchContent(patch);
        break;
      } else if (line.startsWith("*** ")) {
        this.unreadPatchLine();
        this.readContextPatchContent(patch);
        break;
      } else if (isNormalDiffRange(line)) {
        this.unreadPatchLine();
        this.readNormalPatchContent(patch);
        break;
      }
    }
    return patch;
  }

  /**
   * Whether the given {@code line} is a normal diff range.
   *
   * @param line The line to check.
   * @return {@code true} if the given {@code line} is a normal diff range, otherwise {@code false}.
   */
  private boolean isNormalDiffRange(String line) {
    return normalAddRangePattern.matcher(line).matches()
        || normalChangeRangePattern.matcher(line).matches()
        || normalDeleteRangePattern.matcher(line).matches();
  }

  /**
   * Reads binary diff hunk.
   *
   * @param patch The single patch file to read the binary diff hunk.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private void readBinaryPatchContent(PatchSingle patch) throws PatchException, IOException {
    List<Hunk> hunks = new ArrayList<>();
    Hunk hunk = new Hunk();
    while (true) {
      String line = readPatchLine();
      if (line == null || line.startsWith("Index:") || line.length() == 0) {
        this.unreadPatchLine();
        break;
      }
      if (patch.isBinary()) {
        hunk.lines.add(line);
      } else {
        Matcher matcher = binaryHeaderPattern.matcher(line);
        if (matcher.matches()) {
          patch.setBinary(true);
          int length = Integer.parseInt(matcher.group(3));
          if (length == -1) {
            break;
          }
          hunks.add(hunk);
        }
      }
    }
    patch.setHunks(hunks.toArray(new Hunk[hunks.size()]));
  }

  /**
   * Reads normal diff hunks.
   *
   * @param patch The single patch file to read the normal diff hunk.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private void readNormalPatchContent(PatchSingle patch) throws IOException, PatchException {
    List<Hunk> hunks = new ArrayList<>();
    Hunk hunk = null;
    Matcher matcher;
    while (true) {
      String line = readPatchLine();
      if (line == null || line.startsWith("Index:")) {
        this.unreadPatchLine();
        break;
      }
      if ((matcher = normalAddRangePattern.matcher(line)).matches()) {
        hunk = new Hunk();
        hunks.add(hunk);
        this.parseNormalRange(hunk, matcher);
      } else if ((matcher = normalChangeRangePattern.matcher(line)).matches()) {
        hunk = new Hunk();
        hunks.add(hunk);
        this.parseNormalRange(hunk, matcher);
      } else if ((matcher = normalDeleteRangePattern.matcher(line)).matches()) {
        hunk = new Hunk();
        hunks.add(hunk);
        this.parseNormalRange(hunk, matcher);
      } else {
        if (line.startsWith("> ")) {
          hunk.lines.add("+" + line.substring(2));
        } else if (line.startsWith("< ")) {
          hunk.lines.add("-" + line.substring(2));
        } else if (line.startsWith("---")) {
          // Can be ignored
        } else {
          throw new PatchException("Invalid hunk line: " + line);
        }
      }
    }
    patch.setHunks(hunks.toArray(new Hunk[hunks.size()]));
  }

  private void parseNormalRange(Hunk hunk, Matcher matcher) {
    if (matcher.pattern() == normalAddRangePattern) {
      hunk.baseStart = Integer.parseInt(matcher.group(1));
      hunk.baseCount = 0;
      hunk.modifiedStart = Integer.parseInt(matcher.group(2));
      hunk.modifiedCount = Integer.parseInt(matcher.group(3)) - hunk.modifiedStart + 1;
    } else if (matcher.pattern() == normalDeleteRangePattern) {
      hunk.baseStart = Integer.parseInt(matcher.group(1));
      hunk.baseCount = Integer.parseInt(matcher.group(2)) - hunk.baseStart + 1;
      hunk.modifiedStart = Integer.parseInt(matcher.group(3));
      hunk.modifiedCount = 0;
    } else {
      hunk.baseStart = Integer.parseInt(matcher.group(1));
      hunk.baseCount = Integer.parseInt(matcher.group(2)) - hunk.baseStart + 1;
      hunk.modifiedStart = Integer.parseInt(matcher.group(3));
      hunk.modifiedCount = Integer.parseInt(matcher.group(4)) - hunk.modifiedStart + 1;
    }
  }

  /**
   * Reads context diff hunks.
   *
   * @param patch The single patch to read the context diff hunk.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private void readContextPatchContent(PatchSingle patch) throws IOException, PatchException {
    String base = readPatchLine();
    if (base == null || !base.startsWith("*** ")) {
      throw new PatchException("Invalid context diff header: " + base);
    }

    String modified = readPatchLine();
    if (modified == null || !modified.startsWith("--- ")) {
      throw new PatchException("Invalid context diff header: " + modified);
    }

    if (patch.getTargetPath() == null) {
      computeTargetPath(base, modified, patch);
    }

    List<Hunk> hunks = new ArrayList<>();
    Hunk hunk = null;

    int lineCount = -1;
    while (true) {
      String line = this.readPatchLine();
      if (line == null || line.length() == 0 || line.startsWith("Index:")) {
        this.unreadPatchLine();
        break;
      } else if (line.startsWith("***************")) {
        hunk = new Hunk();
        this.parseContextRange(hunk, readPatchLine());
        hunks.add(hunk);
      } else if (line.startsWith("--- ")) {
        lineCount = 0;
        this.parseContextRange(hunk, line);
        if (hunk == null) {
          throw new NullPointerException("The hunk is null!");
        }
        hunk.lines.add(line);
      } else {
        if (hunk == null) {
          throw new NullPointerException("The hunk is null!");
        }
        char character = line.charAt(0);
        if (character == ' ' || character == '+' || character == '-' || character == '!') {
          if (lineCount < hunk.modifiedCount) {
            hunk.lines.add(line);
            if (lineCount != -1) {
              lineCount++;
            }
          }
        } else {
          throw new PatchException("Invalid hunk line: " + line);
        }
      }
    }
    patch.setHunks(hunks.toArray(new Hunk[hunks.size()]));
    convertContextToUnified(patch);
  }

  private void convertContextToUnified(PatchSingle patch) throws PatchException {
    Hunk[] unifiedHunks = new Hunk[patch.getHunks().length];
    int index = 0;
    for (Hunk hunk : patch.getHunks()) {
      unifiedHunks[index++] = convertContextToUnified(hunk);
    }
    patch.setHunks(unifiedHunks);
  }

  private Hunk convertContextToUnified(Hunk hunk) throws PatchException {
    Hunk unifiedHunk = new Hunk();
    unifiedHunk.baseStart = hunk.baseStart;
    unifiedHunk.modifiedStart = hunk.modifiedStart;
    int split = -1;
    for (int i = 0; i < hunk.lines.size(); i++) {
      if (hunk.lines.get(i).startsWith("--- ")) {
        split = i;
        break;
      }
    }
    if (split == -1) {
      throw new PatchException("Missing split divider in context patch");
    }

    int baseIndex = 0;
    int modifiedIndex = split + 1;
    List<String> unifiedLines = new ArrayList<>(hunk.lines.size());
    while (baseIndex < split || modifiedIndex < hunk.lines.size()) {
      String baseLine = baseIndex < split ? hunk.lines.get(baseIndex) : "~";
      String modifiedLine = modifiedIndex < hunk.lines.size() ? hunk.lines.get(modifiedIndex) : "~";
      if (baseLine.startsWith("- ")) {
        unifiedLines.add("-" + baseLine.substring(2));
        unifiedHunk.baseCount++;
        baseIndex++;
      } else if (modifiedLine.startsWith("+ ")) {
        unifiedLines.add("+" + modifiedLine.substring(2));
        unifiedHunk.modifiedCount++;
        modifiedIndex++;
      } else if (baseLine.startsWith("! ")) {
        unifiedLines.add("-" + baseLine.substring(2));
        unifiedHunk.baseCount++;
        baseIndex++;
      } else if (modifiedLine.startsWith("! ")) {
        unifiedLines.add("+" + modifiedLine.substring(2));
        unifiedHunk.modifiedCount++;
        modifiedIndex++;
      } else if (baseLine.startsWith("  ") && modifiedLine.startsWith("  ")) {
        unifiedLines.add(baseLine.substring(1));
        unifiedHunk.baseCount++;
        unifiedHunk.modifiedCount++;
        baseIndex++;
        modifiedIndex++;
      } else if (baseLine.startsWith("  ")) {
        unifiedLines.add(baseLine.substring(1));
        unifiedHunk.baseCount++;
        unifiedHunk.modifiedCount++;
        baseIndex++;
      } else if (modifiedLine.startsWith("  ")) {
        unifiedLines.add(modifiedLine.substring(1));
        unifiedHunk.baseCount++;
        unifiedHunk.modifiedCount++;
        modifiedIndex++;
      } else {
        throw new PatchException("Invalid context patch: " + baseLine);
      }
    }
    unifiedHunk.lines = unifiedLines;
    return unifiedHunk;
  }

  /**
   * Reads unified diff hunks.
   *
   * @param patch The single patch file to read the unified diff hunks.
   * @throws IOException If an I/O error has occurred.
   * @throws PatchException If the patch is invalid.
   */
  private void readPatchContent(PatchSingle patch) throws IOException, PatchException {
    String base = this.readPatchLine();
    if (base == null || !base.startsWith("--- ")) {
      throw new PatchException("Invalid unified diff header: " + base);
    }

    String modified = this.readPatchLine();
    if (modified == null || !modified.startsWith("+++ ")) {
      throw new PatchException("Invalid unified diff header: " + modified);
    }

    if (patch.getTargetPath() == null) {
      this.computeTargetPath(base, modified, patch);
    }

    List<Hunk> hunks = new ArrayList<>();
    Hunk hunk = null;

    while (true) {
      String line = this.readPatchLine();
      if (line == null || line.length() == 0 || line.startsWith("Index:")) {
        this.unreadPatchLine();
        break;
      }
      char c = line.charAt(0);
      if (c == '@') {
        hunk = new Hunk();
        this.parseRange(hunk, line);
        hunks.add(hunk);
      } else if (c == ' ' || c == '+' || c == '-') {
        if (hunk == null) {
          throw new NullPointerException("The hunk is null!");
        }
        hunk.lines.add(line);
      } else if (line.equals(Hunk.ENDING_NEWLINE)) {
        patch.setNoEndingNewline(true);
      } else {
        this.unreadPatchLine();
        break;
      }
    }
    patch.setHunks(hunks.toArray(new Hunk[hunks.size()]));
  }

  private void computeTargetPath(String base, String modified, PatchSingle patch) {
    base = base.substring("+++ ".length());
    modified = modified.substring("--- ".length());

    if ((base.equals("/dev/null") || base.startsWith("a/"))
        && (modified.equals("/dev/null") || modified.startsWith("b/"))) {
      if (base.startsWith("a/")) {
        base = base.substring(2);
      }
      if (modified.startsWith("b/")) {
        modified = modified.substring(2);
      }
    }

    if (this.originalPrefix != null && base.startsWith(this.originalPrefix)) {
      base = base.substring(this.originalPrefix.length());
    }

    if (this.modifiedPrefix != null && modified.startsWith(this.modifiedPrefix)) {
      modified = modified.substring(this.modifiedPrefix.length());
    }

    base = untilTab(base).trim();
    if (base.equals("/dev/null")) {

      patch.setTargetPath(untilTab(modified).trim());
      patch.setPatchMode(PatchMode.ADD);
    } else {
      patch.setTargetPath(base);
      patch.setPatchMode(modified.equals("/dev/null") ? PatchMode.DELETE : PatchMode.CHANGE);
    }
  }

  private String untilTab(String base) {
    int pathEndIndex = base.indexOf('\t');
    if (pathEndIndex > 0) {
      base = base.substring(0, pathEndIndex);
    }
    return base;
  }

  private void parseRange(Hunk hunk, String range) throws PatchException {
    Matcher matcher = unifiedRangePattern.matcher(range);
    if (!matcher.matches()) {
      throw new PatchException("Invalid unified diff range: " + range);
    }
    hunk.baseStart = Integer.parseInt(matcher.group(1));
    hunk.baseCount = matcher.group(2) != null ? Integer.parseInt(matcher.group(2).substring(1)) : 1;
    hunk.modifiedStart = Integer.parseInt(matcher.group(3));
    hunk.modifiedCount =
        matcher.group(4) != null ? Integer.parseInt(matcher.group(4).substring(1)) : 1;
  }

  private void parseContextRange(Hunk hunk, String range) throws PatchException {
    if (range.charAt(0) == '*') {
      Matcher matcher = baseRangePattern.matcher(range);
      if (!matcher.matches()) {
        throw new PatchException("Invalid context diff range: " + range);
      }
      hunk.baseStart = Integer.parseInt(matcher.group(1));
      hunk.baseCount =
          matcher.group(2) != null ? Integer.parseInt(matcher.group(2).substring(1)) : 1;
      hunk.baseCount -= hunk.baseStart - 1;
    } else {
      Matcher matcher = modifiedRangePattern.matcher(range);
      if (!matcher.matches()) {
        throw new PatchException("Invalid context diff range: " + range);
      }
      hunk.modifiedStart = Integer.parseInt(matcher.group(1));
      hunk.modifiedCount =
          matcher.group(2) != null ? Integer.parseInt(matcher.group(2).substring(1)) : 1;
      hunk.modifiedCount -= hunk.modifiedStart - 1;
    }
  }

  /**
   * Retrieves the read patch line.
   *
   * @return The read patch line.
   * @throws IOException If an I/O error has occurred.
   */
  private String readPatchLine() throws IOException {
    if (this.patchLineRead) {
      this.patchLine = this.patchReader.readLine();
    } else {
      this.patchLineRead = true;
    }
    return this.patchLine;
  }

  /** Unread the patched line. */
  private void unreadPatchLine() {
    this.patchLineRead = false;
  }

  private void computeContext(List<PatchSingle> patches) {
    File bestContext = this.suggestedContext;
    int bestContextMatched = 0;
    for (this.context = this.suggestedContext;
        this.context != null;
        this.context = this.context.getParentFile()) {
      int patchedFiles = 0;
      for (PatchSingle patch : patches) {
        try {
          this.applyPatch(patch, true);
          patchedFiles++;
        } catch (Exception ignored) {
        }
      }
      if (patchedFiles > bestContextMatched) {
        bestContextMatched = patchedFiles;
        bestContext = this.context;
        if (patchedFiles == patches.size()) {
          break;
        }
      }
    }
    this.context = bestContext;
  }

  public File computeTargetFile(PatchSingle patch) {
    if (patch.getTargetPath() == null) {
      patch.setTargetPath(this.context.getAbsolutePath());
    }
    if (this.context.isFile()) {
      return this.context;
    }

    return new File(this.context, patch.getTargetPath());
  }

  public boolean isC14nAccess() {
    return this.c14nAccess;
  }

  public boolean isC14nWhitespace() {
    return this.c14nWhitespace;
  }
}
